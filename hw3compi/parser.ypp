%{
	#include "attributes.h"
    #include "output.hpp"
    #include "funcs.h"
    #include<stdio.h>
    #include<string>
    #include<iostream>
    using namespace std;
    using namespace output;
    extern int yylex();
	int yyerror(char * message);
    vector<vector<attribute_t*> > tables;
    vector<int> offsets;
    #define YYDEBUG 1 
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token<string_val> STRUCT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token<string_val> ID
%token NUM
%token<string_val> STRING

%left OR
%left AND
%right ASSIGN
%left EQ
%nonassoc RELATIONAL
%left ADD
%left MUL
%right NOT
%left LPAREN RPAREN PERIOD

%type<attribute_val> FormalDecl;
%type<attributes_list> Formals;
%type<attributes_list> FormalsList;
%type<type_val> Type;
%type<type_val> RetType;
%type<string_val> StructType;
%type<attributes_list> StructMemList;
%type<attribute_val> StructMem;
%%

Program : GlobalScope Structs Funcs EndScope
GlobalScope : 
                {
                     tables.push_back(vector<attribute_t*>(0));
                     offsets.push_back(0);
                     vector<attribute_t*> print_params(1, new attribute_t(TYPE_ENUM_STRING, "str"));
                     vector<attribute_t*> printi_params(1, new attribute_t(TYPE_ENUM_INT, "i"));
                     functionAttribute* print_attr = new functionAttribute(
                        "print",
                        TYPE_ENUM_VOID /* return_type */,
                        print_params);
                     functionAttribute* printi_attr = new functionAttribute(
                        "printi",
                        TYPE_ENUM_VOID /* return_type */,
                        printi_params);
                    tables.back().push_back(print_attr);
                    tables.back().push_back(printi_attr);

                }
            ;
Funcs : 
 | FuncDecl Funcs
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE FuncScope AtLeastOneOpenStatement RBRACE EndScope
| RetType ID LPAREN Formals RPAREN LBRACE FuncScope ClosedStatements RBRACE EndScope
FuncScope:  
                {
                    vector<attribute_t*>* formals = yyvsp[-2].attributes_list;
                    string id = *(yyvsp[-4].string_val);
                    type_enum_t return_type = yyvsp[-5].type_val;
                    tables[tables.size()-1].push_back(new functionAttribute(
                         id /* name */,
                         return_type,
                         *formals /* parameters */));

                    tables.push_back(vector<attribute_t*>(0));

                    // Function scope always starts with offset 0
                    offsets.push_back(0);

                    // Add function parameters to the current table, from leftmost to rightmost
                    // parameter.
                    // Note that leftmost parameter is the last in "formals" array due to the way
                    // the aprameters are derived.
                    for(int i=formals->size()-1; i>=0; i--)
                    {
                        // Decrease offset because function parameters reside in negative offsets
                        tables.back().push_back((*formals)[i]);
                        offsets.back()-=tables.back().back()->get_size();
                        tables.back().back()->offset=offsets.back();
                    }

                    // Return offset to 0 because fuction scope always starts with offset 0
                    offsets.back()=0;
                }
                ;
Structs : 
| StructsDecl Structs
StructsDecl : STRUCT ID LBRACE StructMemList RBRACE SC AddStructSymbol
AddStructSymbol:
                {
                string id = *(yyvsp[-4].string_val);
                vector<attribute_t*> members = *(yyvsp[-2].attributes_list);
                tables.back().push_back(new structDeclerationAttribute(id, members));
                }
RetType : Type {$$ = $1;}
| VOID {$$ = TYPE_ENUM_VOID;}
Formals : {$$ = new vector<attribute_t*>(0);}
| FormalsList {$$ = $1;}
FormalsList : FormalDecl  {$$ = new vector<attribute_t*>(1, $1);}
| FormalDecl COMMA FormalsList
             {
                $$ = $3;
                (*$$).push_back($1);
             }
             ;
FormalDecl : Type ID {$$ = new attribute_t($1, *($2));}
| StructType ID {$$ = new structVariableAttribute(*($1), *($2));}
StructMemList : StructMem {$$ = new vector<attribute_t*>(1, $1);}
| StructMem StructMemList
            {
                $$ = $2;
                (*$$).push_back($1);
            }
            ;
StructMem : Type ID SC {$$ = new attribute_t($1, *($2));}

// Define rules for parsing statements in such a way the "dangling else" conflict will be solved.
// In order to solve the "danlging else" conflict, we define the grammar rules in such a way that
// when we get a list of "if"s and "else"s we do the following parsing:
// Starting from the leftmost "else", match every "else" to the rightest free "if" on its left
// (a "free if" is an if which we didn't match it an "else" yet).
// For supporting the above behavior, We divivde statements to "open statements" and "closed 
// statements".
// an "open statement" is defined to be a statement that includes at least one "if" without matching 
// else.
// and a "closed statement" is defined to be a statements in which every "if" has matching "else".
// The following rules support parsing "Statements" while keeping the behaviour explained above. 


// We define "AtLeastOneOpenStatement" to be a list of statements which contain some number of statements,
// but one of these statements have to be open statement
/* Option 1: this list contains mere one open statement */
AtLeastOneOpenStatement: OpenStatement
/* Option2: this list ends with an open statement, and the rest of the list can contain any
   kind of statements */
| AtLeastOneOpenStatement OpenStatement
| ClosedStatements OpenStatement
/* Option3: this list can ends with a closed statement, and the rest of the list must contain at
   least one open statement, which means the rest of the list is of the kind "AtLeastOneOpenStatement" */ 
| AtLeastOneOpenStatement ClosedStatement

// We define "ClosedStatements" to be a list of closed statements
ClosedStatements: ClosedStatement
| ClosedStatements ClosedStatement

// Rules for an open statement.
// Note that a statement is only considered open if it contains at least one "if" which doesn't
// have a matching "else".
// Therefore, an open statement must either start with "if" or "while", or to consist of "LBRACE
// AtLeastOneOpenStatement RBRACE", because according to the grammar rules, these are the only ways
// for a statement to contain an "if".
/* Option1: the statement starts with "if" which doesn't have its matching else.
   Note that in this case the "if" block can contain any kind of statement (open or closed) */
OpenStatement: IF LPAREN Exp RPAREN NewScope OpenStatement EndScope
| IF LPAREN Exp RPAREN NewScope ClosedStatement EndScope
/* Option2: the statement starts with "if" which have its matching else.
   Note that in this case the "if" block can only contain closed statement, because otherwise, it
   would contain at least one "if" without a matching else, but according to our behaviour for
   dealing with multiple "if"s and "else"s list (see explanation above),  this "if" must be matched
   to the "ELSE" in the current rule */
| IF LPAREN Exp RPAREN NewScope ClosedStatement EndScope ELSE NewScope OpenStatement EndScope
/* Option3: the statement starts with "while".
   Note In this case, the "while" block must contain at least one "if" without its matching "else",
   which means it must contain "OpenStatement" */
| WHILE LPAREN Exp RPAREN NewScope OpenStatement  EndScope
/* Option4: the statement consist of LBRACE AtLeastOneOpenStatement RBRACE */
| LBRACE NewScope AtLeastOneOpenStatement RBRACE EndScope

// Rules for a closed statement.
// Note that in a closed statement, every if must have its matching else.
ClosedStatement: SimpleStatement
| IF LPAREN Exp RPAREN NewScope ClosedStatement EndScope ELSE NewScope ClosedStatement EndScope
| WHILE LPAREN Exp RPAREN NewScope ClosedStatement EndScope
| LBRACE NewScope ClosedStatements RBRACE EndScope

NewScope: 
          {
            tables.push_back(vector<attribute_t*>(0));
            offsets.push_back(offsets[offsets.size()-1]);
          }
          ;
EndScope :
          {
              endScope();
              for(int i=0; i<tables.back().size(); i++)
              {
                    if(tables.back()[i]->type != TYPE_ENUM_STRUCT_DECLERATION )
                       {
                            string symbol_type = get_type_string(tables.back()[i]);
                            printID(tables.back()[i]->name,tables.back()[i]->offset, symbol_type);
                       }
              }
              for(int i=0; i<tables.back().size(); i++)
              {
                    if(tables.back()[i]->type == TYPE_ENUM_STRUCT_DECLERATION )
                       {
                            structDeclerationAttribute* struct_dec =
                                dynamic_cast<structDeclerationAttribute*>(tables.back()[i]);
                            vector<string> memTypes, memNames;
                            // Get member types and names as the same order they were defined.
                            // Note that struct_dec->members contain the members in a reversed
                            // order.
                            for(int j=struct_dec->members.size()-1; j>=0; j--)
                            {
                                memTypes.push_back(get_type_string(struct_dec->members[j]));
                                memNames.push_back(struct_dec->members[j]->name);
                            }
                            printStructType(struct_dec->name, memTypes, memNames);
                       }
              }
              tables.pop_back();
              offsets.pop_back();
          }
          ;
SimpleStatement: Type ID SC 
                    {
                        tables[tables.size()-1].push_back(new attribute_t($1, *($2)));
                        offsets[offsets.size()-1]++;
                    }
                    ;
| StructType ID SC 
                    {
                        tables[tables.size()-1].push_back(new structVariableAttribute(*($1), *($2)));
                        offsets[offsets.size()-1] += tables.back().back()->get_size();
                    }
                    ;
| STRUCT ID LBRACE StructMemList RBRACE SC  AddStructSymbol
| Type ID ASSIGN Exp SC 
                    {
                        tables[tables.size()-1].push_back(new attribute_t($1, *($2)));
                        offsets[offsets.size()-1]++;
                    }
| StructType ID ASSIGN Exp SC 
                    {
                        tables.back().push_back(new structVariableAttribute(*($1), *($2)));
                        offsets.back() += tables.back().back()->get_size();
                    }
| ID ASSIGN Exp SC 
| ID PERIOD ID ASSIGN Exp SC 
| Call SC 
| RETURN SC 
| RETURN Exp SC 
| BREAK SC 
| CONTINUE SC
Call : ID LPAREN ExpList RPAREN 
| ID LPAREN RPAREN
ExpList : Exp 
| Exp COMMA ExpList
Type : INT {$$ = TYPE_ENUM_INT;}
| BYTE {$$ = TYPE_ENUM_BYTE;}
| BOOL {$$ = TYPE_ENUM_BOOL;}
StructType : STRUCT ID {$$ = $2;}
Exp :LPAREN Exp RPAREN %prec LPAREN
| Exp ADD Exp %prec ADD
| Exp MUL Exp %prec MUL
| ID 
| ID PERIOD ID 
| Call 
| NUM 
| NUM B 
| STRING 
| TRUE 
| FALSE 
| NOT Exp %prec NOT
| Exp AND Exp %prec AND
| Exp OR Exp %prec OR
| Exp RELATIONAL Exp %prec RELATIONAL
| Exp EQ Exp %prec EQ

%%

int main()
{
    yydebug = 1;
	tables = vector<vector<attribute_t*> >(0);
    offsets = vector<int>(0);
    yyparse();
    return 0;
}

int yyerror(char * message)
{
return 0;
}