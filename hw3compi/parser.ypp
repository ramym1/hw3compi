%{
	#include "attributes.h"
    #include "output.hpp"
    #include "funcs.h"
    #include<stdio.h>
    #include<string>
    #include<iostream>
    #include<vector>
    using namespace std;
    using namespace output;
    extern int yylex();
    extern int yylineno;
	int yyerror(char * message);
    vector<vector<attribute_t*> > tables;
    vector<int> offsets;
    int err_line;
    int inside_loop = 0;
    int err_line_struct;
    int err_line_func;
    #define YYDEBUG 1 
	/* hw5  */
	#include "regs_pool.h"
	/*std::list<function> functionsList;*/
	regs_pool* regsPool= new regs_pool ;

    // This label is used when backpatching jump instructions when there is a need for single backpatch,
    // and it is used for the first backpatch when there is a need for a two backpatches.
    // See GENERATE_AND_EMIT_LABEL marker.
    std::string label_to_jump;

    // When there is a need for performng two backpatches, this label is used for the second backpatch.
    // See GENERATE_AND_EMIT_LABEL2 marker.
    std::string label_to_second_jump;

    // This offset corresponds to the offset in CodeBuffer of the last "j " instruction which was
    // emitted before encountering an "else" statement (see "EMIT_JUMP_BEFORE_ELSE" marker).
    // This offset will be pushed to the next list of the entire "if ... else ..." statement, so
    // the instruction will be eventually backpatched.
    int jump_offset_before_else;
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token<string_val> STRUCT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token<string_val> ID
%token<string_val> NUM
%token<string_val> STRING

%left OR
%left AND
%right ASSIGN

// hw5: updated "EQ" to be of "string_val" type
%left<string_val> EQ

// hw5: updated "RELATIONAL" to be of "string_val" type
%nonassoc<string_val> RELATIONAL
%left ADD
%left MUL
%right NOT
%left LPAREN RPAREN PERIOD

%type<attribute_val> FormalDecl;
%type<attributes_list> Formals;
%type<attributes_list> FormalsList;
%type<type_val> Type;
%type<type_val> RetType;
%type<string_val> StructType;
%type<attributes_list> StructMemList;
%type<attribute_val> StructMem;
%type<expression_val> Exp;
%type<expressions_list> ExpList;
%type<type_val> Call;
%type<statement_val> OpenStatement;
%type<statement_val> AtLeastOneOpenStatement;
%type<statement_val> ClosedStatement;
%type<statement_val> ClosedStatements;
%type<statement_val> SimpleStatement;
%%

Program : GlobalScope Structs Funcs EndScope
GlobalScope : 
                {
                     tables.push_back(vector<attribute_t*>(0));
                     offsets.push_back(0);
                     vector<attribute_t*> print_params(1, new attribute_t(TYPE_ENUM_STRING, "str"));
                     vector<attribute_t*> printi_params(1, new attribute_t(TYPE_ENUM_INT, "i"));
                     functionAttribute* print_attr = new functionAttribute(
                        "print",
                        TYPE_ENUM_VOID /* return_type */,
                        print_params);
                     functionAttribute* printi_attr = new functionAttribute(
                        "printi",
                        TYPE_ENUM_VOID /* return_type */,
                        printi_params);
                    tables.back().push_back(print_attr);
                    tables.back().back()->line_num = -1;
                    tables.back().push_back(printi_attr);
                    tables.back().back()->line_num = -1;

                }
            ;
SLNF: {err_line_func = yylineno;}
SLNFC: {err_line_struct = yylineno;}
StoreLineNum: {err_line = yylineno;}
Funcs : 
 | FuncDecl Funcs
FuncDecl : RetType StoreLineNum SLNF ID LPAREN Formals RPAREN LBRACE FuncScope AtLeastOneOpenStatement RBRACE EndScope
| RetType StoreLineNum SLNF ID LPAREN Formals RPAREN LBRACE FuncScope ClosedStatements RBRACE EndScope
FuncScope:  
                {
                    vector<attribute_t*>* formals = yyvsp[-2].attributes_list;
                    string id = *(yyvsp[-4].string_val);
                    if(id_is_defined(id))
                    {
                        errorDef(err_line_func, id);
                        exit(0);
                    }
                    type_enum_t return_type = yyvsp[-7].type_val;
                    tables[tables.size()-1].push_back(new functionAttribute(
                         id /* name */,
                         return_type,
                         *formals /* parameters */));

                    tables.back().back()->line_num = err_line_func;

                    tables.push_back(vector<attribute_t*>(0));

                    // Function scope always starts with offset 0
                    offsets.push_back(0);

                    // Add function parameters to the current table, from leftmost to rightmost
                    // parameter.
                    // Note that leftmost parameter is the last in "formals" array due to the way
                    // the aprameters are derived.
                    for(int i=formals->size()-1; i>=0; i--)
                    {
                        if (id_is_defined((*formals)[i]->name))
                        {
                            errorDef((*formals)[i]->line_num, (*formals)[i]->name);
                            exit(0);
                        }
                        // Decrease offset because function parameters reside in negative offsets
                        tables.back().push_back((*formals)[i]);
                        offsets.back()-=tables.back().back()->get_size();
                        tables.back().back()->offset=offsets.back();
                    }

                    // Return offset to 0 because fuction scope always starts with offset 0
                    offsets.back()=0;
                }
                ;
Structs : 
| StructsDecl Structs
StructsDecl : STRUCT StoreLineNum SLNFC ID LBRACE StructMemList RBRACE SC AddStructSymbol
AddStructSymbol:
                {
                string id = *(yyvsp[-4].string_val);
                if (id_is_defined(id))
                {
                    errorDef(err_line_struct, id);
                    exit(0);
                }
                vector<attribute_t*> members = *(yyvsp[-2].attributes_list);
                tables.back().push_back(new structDeclerationAttribute(id, members));
                tables.back().back()->line_num = err_line;
                }
RetType : Type 
        {
            if($1 == TYPE_ENUM_STRING)
            {
                // string is only allowed for print
                errorMismatch(yylineno);
                exit(0);
            }
            $$ = $1;
        }
| VOID {$$ = TYPE_ENUM_VOID;}
Formals : {$$ = new vector<attribute_t*>(0);}
| FormalsList {$$ = $1;}
FormalsList : FormalDecl  {$$ = new vector<attribute_t*>(1, $1);}
| FormalDecl COMMA FormalsList
             {
                $$ = $3;
                (*$$).push_back($1);
             }
             ;
FormalDecl : Type ID 
            {
                if ($1 == TYPE_ENUM_STRING)
                {
                     errorMismatch(yylineno);
                     exit(0);
                }
                $$ = new attribute_t($1, *($2));
                $$->line_num = yylineno;
            }
| StructType ID 
                {
                    $$ = new structVariableAttribute(*($1), *($2));
                    $$->line_num = yylineno;
                    if (!id_is_defined(*($1)))
                    {
                        errorUndefStruct(yylineno, *($1));
                        exit(0);
                    }
                }
StructMemList : StructMem {$$ = new vector<attribute_t*>(1, $1);}
| StructMem StructMemList
            {
                for (int i=$2->size()-1; i>=0; i--)
                {
                    if((*$2)[i]->name == $1->name)
                    {
                        errorDef((*$2)[i]->line_num, $1->name);
                        exit(0);
                    }
                }
                $$ = $2;
                (*$$).push_back($1);
            }
            ;
StructMem : Type StoreLineNum ID SC 
                    {
                        if ($1 == TYPE_ENUM_STRING)
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }
                        $$ = new attribute_t($1, *($3));
                        $$->line_num = err_line;
                    }

// Define rules for parsing statements in such a way the "dangling else" conflict will be solved.
// In order to solve the "danlging else" conflict, we define the grammar rules in such a way that
// when we get a list of "if"s and "else"s we do the following parsing:
// Starting from the leftmost "else", match every "else" to the rightest free "if" on its left
// (a "free if" is an if which we didn't match it an "else" yet).
// For supporting the above behavior, We divivde statements to "open statements" and "closed 
// statements".
// an "open statement" is defined to be a statement that includes at least one "if" without matching 
// else.
// and a "closed statement" is defined to be a statements in which every "if" has matching "else".
// The following rules support parsing "Statements" while keeping the behaviour explained above. 


// We define "AtLeastOneOpenStatement" to be a list of statements which contain some number of statements,
// but one of these statements have to be open statement
/* Option 1: this list contains mere one open statement */
AtLeastOneOpenStatement: OpenStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> S"
    $$ = $1;
}
/* Option2: this list ends with an open statement, and the rest of the list can contain any
   kind of statements */
| AtLeastOneOpenStatement GENERATE_AND_EMIT_LABEL OpenStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> L1 M S"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of "OpenStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($1->next_list, label_to_jump);

    $$->next_list = $3->next_list;
}
| ClosedStatements GENERATE_AND_EMIT_LABEL OpenStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> L1 M S"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of "OpenStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($1->next_list, label_to_jump);

    $$->next_list = $3->next_list;
}
/* Option3: this list can ends with a closed statement, and the rest of the list must contain at
   least one open statement, which means the rest of the list is of the kind "AtLeastOneOpenStatement" */ 
| AtLeastOneOpenStatement GENERATE_AND_EMIT_LABEL ClosedStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> L1 M S"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of "ClosedStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($1->next_list, label_to_jump);

    $$->next_list = $3->next_list;
}

// We define "ClosedStatements" to be a list of closed statements
ClosedStatements: ClosedStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> S"
    $$ = $1;
}
| ClosedStatements GENERATE_AND_EMIT_LABEL ClosedStatement
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "L -> L1 M S"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of "ClosedStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($1->next_list, label_to_jump);

    $$->next_list = $3->next_list;
}
// Rules for an open statement.
// Note that a statement is only considered open if it contains at least one "if" which doesn't
// have a matching "else".
// Therefore, an open statement must either start with "if" or "while", or to consist of "LBRACE
// AtLeastOneOpenStatement RBRACE", because according to the grammar rules, these are the only ways
// for a statement to contain an "if".
/* Option1: the statement starts with "if" which doesn't have its matching else.
   Note that in this case the "if" block can contain any kind of statement (open or closed) */
OpenStatement: IF LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL OpenStatement EndScope
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> if (B) M S1"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the true list
    // of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($3->true_list, label_to_jump);

    // Set the next list of the result "OpenStatement" to contain all of the offsets in the false
    // list of "Exp" and the next list of the inner "OpenStatement""
    $$->next_list = CodeBuffer::instance().merge($3->false_list, $8->next_list);
}
| IF LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL ClosedStatement EndScope
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> if (B) M S1"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the true list
    // of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($3->true_list, label_to_jump);

    // Set the next list of the result "OpenStatement" to contain all of the offsets in the false
    // list of "Exp" and the next list of the inner "OpenStatement""
    $$->next_list = CodeBuffer::instance().merge($3->false_list, $8->next_list);
}
/* Option2: the statement starts with "if" which have its matching else.
   Note that in this case the "if" block can only contain closed statement, because otherwise, it
   would contain at least one "if" without a matching else, but according to our behaviour for
   dealing with multiple "if"s and "else"s list (see explanation above),  this "if" must be matched
   to the "ELSE" in the current rule */
| IF LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL ClosedStatement EndScope EMIT_JUMP_BEFORE_ELSE ELSE NewScope GENERATE_AND_EMIT_LABEL2 OpenStatement EndScope
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> if (B) M1 S1 N
    // else M2 S2"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the true list of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($3->true_list, label_to_jump);

    // set "label_to_second_jump" as the jump destination of all branches in the false list of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL2" marker.
    CodeBuffer::instance().bpatch($3->false_list, label_to_second_jump);

    // Set the next list of the result "OpenStatement" to contain "jump_offset_for_else", all of
    // the offsets in the "ClosedStatement" which is inside the "if" block and all of the offsets
    // in the next list of the "OpenStatement" which is inside the "else" block
    $$->next_list = CodeBuffer::instance().merge($8->next_list, vector<int>(1, jump_offset_before_else));
    $$->next_list = CodeBuffer::instance().merge($$->next_list, $14->next_list);
}
/* Option3: the statement starts with "while".
   Note In this case, the "while" block must contain at least one "if" without its matching "else",
   which means it must contain "OpenStatement" */
| WHILE EnterLoop  GENERATE_AND_EMIT_LABEL LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL2 OpenStatement EndScope ExitLoop
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> while M1 (B)
    // M2 S1"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of the inner "OpenStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($10->next_list, label_to_jump);

    // set "label_to_jump" as the jump destination of all branches in the "continue_list"
    // of the inner "OpenStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($10->continue_list, label_to_jump);

    // set "label_to_second_jump" as the jump destination of all branches in the true list
    // of "Exp".
    // Note that "label_to_second_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL2" marker.
    CodeBuffer::instance().bpatch($5->true_list, label_to_second_jump);

    // Set the next list of the result "OpenStatement" to contain all the offsets in the false list
    // of "Exp" and "break_list" of the "OpenStatement" which is inside the while block
    $$->next_list = CodeBuffer::instance().merge($5->false_list, $10->break_list);

    CodeBuffer::instance().emit("goto " + label_to_jump);
}
/* Option4: the statement consist of LBRACE AtLeastOneOpenStatement RBRACE */
| LBRACE NewScope AtLeastOneOpenStatement RBRACE EndScope
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> { L }"
    $$ = $3;
}

// Rules for a closed statement.
// Note that in a closed statement, every if must have its matching else.
ClosedStatement: SimpleStatement
{
    /* hw5 */
    $$ = $1;
}
| IF LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL ClosedStatement EndScope EMIT_JUMP_BEFORE_ELSE ELSE NewScope GENERATE_AND_EMIT_LABEL2 ClosedStatement EndScope
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> if (B) M1 S1 N
    // else M2 S2"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the true list of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($3->true_list, label_to_jump);

    // set "label_to_second_jump" as the jump destination of all branches in the false list of "Exp".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL2" marker.
    CodeBuffer::instance().bpatch($3->false_list, label_to_second_jump);

    // Set the next list of the result "ClosedStatement" to contain "jump_offset_for_else", all of
    // the offsets in the "ClosedStatement" which is inside the "if" block and all of the offsets
    // in the next list of the "ClosedStatement" which is inside the "else" block
    $$->next_list = CodeBuffer::instance().merge($8->next_list, vector<int>(1, jump_offset_before_else));
    $$->next_list = CodeBuffer::instance().merge($$->next_list, $14->next_list);
}
| WHILE EnterLoop GENERATE_AND_EMIT_LABEL LPAREN Exp CheckExpBool RPAREN NewScope GENERATE_AND_EMIT_LABEL2 ClosedStatement EndScope ExitLoop
{
    /* hw5 */
    // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
    // "S -> while M1 (B)
    // M2 S1"

    $$ = new statement_t();

    // set "label_to_jump" as the jump destination of all branches in the next list
    // of the inner "ClosedStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($10->next_list, label_to_jump);

    // set "label_to_jump" as the jump destination of all branches in the "continue_list"
    // of the inner "ClosedStatement".
    // Note that "label_to_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL" marker.
    CodeBuffer::instance().bpatch($10->continue_list, label_to_jump);

    // set "label_to_second_jump" as the jump destination of all branches in the true list
    // of "Exp".
    // Note that "label_to_second_jump" is a label that was generated and emitted by
    // "GENERATE_AND_EMIT_LABEL2" marker.
    CodeBuffer::instance().bpatch($5->true_list, label_to_second_jump);

    // Set the next list of the result "OpenStatement" to contain all the offsets in the false list
    // of "Exp" and "break_list" of the "ClosedStatement" which is inside the while block
    $$->next_list = CodeBuffer::instance().merge($5->false_list, $10->break_list);

    CodeBuffer::instance().emit("goto " + label_to_jump);
}
| LBRACE NewScope ClosedStatements RBRACE EndScope
{
    /* hw5 */
    $$ = $3;
}

CheckExpBool :
    {
        if(yyvsp[0].expression_val->type != TYPE_ENUM_BOOL)
        {
            errorMismatch(yylineno);
            exit(0);
        }
    }

EnterLoop:{inside_loop++;}
ExitLoop:{inside_loop--;}

NewScope: 
          {
            tables.push_back(vector<attribute_t*>(0));
            offsets.push_back(offsets[offsets.size()-1]);
          }
          ;
EndScope :
          {
              // Check whether we are about to reduce the global scope
              if(tables.size() == 1)
              {
                    if(!main_exists())
                    {
                         errorMainMissing();
                         exit(0);
                    }
              }
              // hw5: Removed output
              //endScope();
              for(int i=0; i<tables.back().size(); i++)
              {
                    if(tables.back()[i]->type != TYPE_ENUM_STRUCT_DECLERATION )
                       {
                            string symbol_type = get_type_string(tables.back()[i]);
                            // hw5: removed output
                            // printID(tables.back()[i]->name,tables.back()[i]->offset, symbol_type);
                       }
              }
              for(int i=0; i<tables.back().size(); i++)
              {
                    if(tables.back()[i]->type == TYPE_ENUM_STRUCT_DECLERATION )
                       {
                            structDeclerationAttribute* struct_dec =
                                dynamic_cast<structDeclerationAttribute*>(tables.back()[i]);
                            vector<string> memTypes, memNames;
                            // Get member types and names as the same order they were defined.
                            // Note that struct_dec->members contain the members in a reversed
                            // order.
                            for(int j=struct_dec->members.size()-1; j>=0; j--)
                            {
                                memTypes.push_back(get_type_string(struct_dec->members[j]));
                                memNames.push_back(struct_dec->members[j]->name);
                            }

                            // hw5: removed output
                            // printStructType(struct_dec->name, memTypes, memNames);
                       }
              }
              tables.pop_back();
              offsets.pop_back();
          }
          ;
SimpleStatement: Type StoreLineNum ID SC 
                    {
                        if(id_is_defined(*($3)))
                        {
                            errorDef(err_line, *($3));
                            exit(0);
                        }
                        if($1 == TYPE_ENUM_STRING)
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }
                        tables[tables.size()-1].push_back(new attribute_t($1, *($3)));
                        tables.back().back()->line_num = err_line;
                        offsets[offsets.size()-1]++;

                        /* hw5 */
                        $$ = new statement_t();
                    }
                    ;
| StructType StoreLineNum ID SC 
                    {
                        if(id_is_defined(*($3)))
                        {
                            errorDef(err_line, *($3));
                            exit(0);
                        }
                        if(!id_is_defined(*($1)))
                        {
                            errorUndefStruct(err_line, *($1));
                            exit(0);
                        }
                        tables[tables.size()-1].push_back(new structVariableAttribute(*($1), *($3)));
                        tables.back().back()->line_num = err_line;
                        offsets[offsets.size()-1] += tables.back().back()->get_size();

                        /* hw5 */
                        $$ = new statement_t();
                    }
                    ;
| STRUCT StoreLineNum SLNFC ID LBRACE StructMemList RBRACE SC  AddStructSymbol
{
                        /* hw5 */
                        $$ = new statement_t();
}
| Type StoreLineNum ID ASSIGN Exp SC 
                    {
                        if(id_is_defined(*($3)))
                        {
                            errorDef(err_line, *($3));
                            exit(0);
                        }
                        if($1 == TYPE_ENUM_STRING)
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }

                        tables[tables.size()-1].push_back(new attribute_t($1, *($3)));
                        tables.back().back()->line_num = err_line;
                        offsets[offsets.size()-1]++;

                        expression_t* id_exp = new expression_t(get_type_by_name(*($3)));
                        if(id_exp->type == TYPE_ENUM_STRUCT_VAR)
                        {
                            id_exp->sub_type = get_struct_subtype(*($3));
                        }
                        if(!assign_allowed(id_exp, $5))
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }
                        /* hw5 */
                        $$ = new statement_t();
                    }
| StructType StoreLineNum ID ASSIGN Exp SC 
                    {
                        if(id_is_defined(*($3)))
                        {
                            errorDef(err_line, *($3));
                            exit(0);
                        }
                        if(!id_is_defined(*($1)))
                        {
                            errorUndefStruct(err_line, *($1));
                            exit(0);
                        }

                        tables.back().push_back(new structVariableAttribute(*($1), *($3)));
                        tables.back().back()->line_num = err_line;
                        offsets.back() += tables.back().back()->get_size();

                        expression_t* id_exp = new expression_t(get_type_by_name(*($3)));
                        if(id_exp->type == TYPE_ENUM_STRUCT_VAR)
                        {
                            id_exp->sub_type = get_struct_subtype(*($3));
                        }
                        if(!assign_allowed(id_exp, $5))
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }
                        /* hw5 */
                        $$ = new statement_t();
                    }
| ID StoreLineNum ASSIGN Exp SC 
    {
        if(!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) == TYPE_ENUM_FUNCTION ||
            get_type_by_name(*($1)) == TYPE_ENUM_STRUCT_DECLERATION)
        {
            errorUndef(err_line, *($1));
            exit(0);
        }

                         expression_t* id_exp = new expression_t(get_type_by_name(*($1)));
                        if(id_exp->type == TYPE_ENUM_STRUCT_VAR)
                        {
                            id_exp->sub_type = get_struct_subtype(*($1));
                        }
                        if(!assign_allowed(id_exp, $4))
                        {
                            errorMismatch(err_line);
                            exit(0);
                        }
                        /* hw5 */
                        $$ = new statement_t();
    }

| ID StoreLineNum PERIOD ID ASSIGN Exp SC 
    {
        if(!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) != TYPE_ENUM_STRUCT_VAR)
        {
            errorUndef(err_line, *($1));
            exit(0);
        }
        if(!struct_has_member_with_name(*($1), *($4)))
        {
            errorUndefStructMember(err_line, *($1));
            exit(0);
        }
        type_enum_t mem_type = get_struct_member_type (*($1), *($4));
        expression_t* mem_exp = new expression_t(mem_type);
        assert(mem_exp->type != TYPE_ENUM_STRUCT_VAR);
        if(!assign_allowed(mem_exp, $6))
        {
            errorMismatch(err_line);
            exit(0);
        }
        /* hw5 */
        $$ = new statement_t();
    }
| Call StoreLineNum SC
{
                        /* hw5 */
                        $$ = new statement_t();
}
| RETURN StoreLineNum SC 
    {
        // Last thing we stored globally must be function
        assert(tables[0].back()->type == TYPE_ENUM_FUNCTION);
        functionAttribute* current_func = dynamic_cast<functionAttribute*>(tables[0].back());
        if(current_func->return_type != TYPE_ENUM_VOID)
        {
            errorMismatch(yylineno);
            exit(0);
        }
        /* hw5 */
        $$ = new statement_t();
    }
| RETURN Exp StoreLineNum SC 
    {
        // Last thing we stored globally must be function
        assert(tables[0].back()->type == TYPE_ENUM_FUNCTION);
        functionAttribute* current_func = dynamic_cast<functionAttribute*>(tables[0].back());
        if(!assign_allowed(new expression_t(current_func->return_type), $2))
        {
            errorMismatch(yylineno);
            exit(0);
        }
        /* hw5 */
        $$ = new statement_t();
    }
| BREAK StoreLineNum SC 
    {
        if(inside_loop == 0)
        {
            errorUnexpectedBreak(err_line);
            exit(0);
        }

        /* hw5 */
        $$ = new statement_t();
        int offset = CodeBuffer::instance().emit("j ");
        $$->break_list = CodeBuffer::instance().makelist(offset);
    }
| CONTINUE StoreLineNum SC
    {
        if(inside_loop == 0)
        {
            errorUnexpectedContinue(err_line);
            exit(0);
        }

        /* hw5 */
        $$ = new statement_t();
        int offset = CodeBuffer::instance().emit("j ");
        $$->continue_list = CodeBuffer::instance().makelist(offset);
    }
    ;
Call : ID StoreLineNum LPAREN ExpList RPAREN 
    {
        if (!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) != TYPE_ENUM_FUNCTION)
            {
                errorUndefFunc(err_line, *($1));
                exit(0);
            }
        $$ = get_function_ret_val_by_name(*($1));
        if(!function_parameters_match(*($1), $4))
        {
            // errorPrototypeMismatch
            vector<string> types;
            functionAttribute* function = get_function(*($1));
            for (int i=function->parameters.size()-1; i>=0; i--)
            {
                types.push_back(get_type_string(function->parameters[i]));
            }
            errorPrototypeMismatch(err_line, *($1), types);
            exit(0);
        }
    }
| ID StoreLineNum LPAREN RPAREN
    {
            if (!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) != TYPE_ENUM_FUNCTION)
            {
                errorUndefFunc(err_line, *($1));
                exit(0);
            }
        $$ = get_function_ret_val_by_name(*($1));
        vector<expression_t*>* vec = new vector<expression_t*>(0);
        if(!function_parameters_match(*($1), vec))
        {
            // errorPrototypeMismatch
            vector<string> types;
            functionAttribute* function = get_function(*($1));
            for (int i=function->parameters.size()-1; i>=0; i--)
            {
                types.push_back(get_type_string(function->parameters[i]));
            }
            errorPrototypeMismatch(err_line, *($1), types);
            exit(0);
        }
        $$ = get_function_ret_val_by_name(*($1)); 
    }
ExpList : Exp {$$ = new vector<expression_t*>(1, $1);}
| Exp COMMA ExpList
    {
        $$ = $3;
        $$->push_back($1);
    }
Type : INT {$$ = TYPE_ENUM_INT;}
| BYTE {$$ = TYPE_ENUM_BYTE;}
| BOOL {$$ = TYPE_ENUM_BOOL;}
StructType : STRUCT StoreLineNum SLNFC ID {$$ = $4;}
Exp :LPAREN Exp RPAREN %prec LPAREN
    {
        $$ = $2;

    }
| Exp ADD Exp %prec ADD
    {
        if(!type_is_numeric($1->type) || !type_is_numeric($3->type))
        {
            errorMismatch(yylineno);
            exit(0);
        }
        if($1->type == TYPE_ENUM_INT || $3->type == TYPE_ENUM_INT)
        {
            $$ = new expression_t(TYPE_ENUM_INT);
        }
        else
        {
            $$ = new expression_t(TYPE_ENUM_BYTE);
        }
    }
| Exp MUL Exp %prec MUL
    {
        if(!type_is_numeric($1->type) || !type_is_numeric($3->type))
        {
            errorMismatch(yylineno);
            exit(0);
        }
        if($1->type == TYPE_ENUM_INT || $3->type == TYPE_ENUM_INT)
        {
            $$ = new expression_t(TYPE_ENUM_INT);
        }
        else
        {
            $$ = new expression_t(TYPE_ENUM_BYTE);
        }
    }
| ID 
    {
        if(!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) == TYPE_ENUM_FUNCTION ||
            get_type_by_name(*($1)) == TYPE_ENUM_STRUCT_DECLERATION)
        {
            errorUndef(yylineno, *($1));
            exit(0);
        }
        $$ = new expression_t(get_type_by_name(*($1)));
        if ($$->type == TYPE_ENUM_STRUCT_VAR)
        {
            $$->sub_type = get_struct_subtype(*($1));
        }
    }
| ID PERIOD ID 
    {
        if(!id_is_defined(*($1)) ||
            get_type_by_name(*($1)) != TYPE_ENUM_STRUCT_VAR)
        {
            errorUndef(yylineno, *($1));
            exit(0);
        }
        if(!struct_has_member_with_name(*($1), *($3)))
        {
            errorUndefStructMember(yylineno, *($1));
            exit(0);
        }
        $$ = new expression_t(get_struct_member_type(*($1), *($3)));
    }
| Call {$$ = new expression_t($1);}
| NUM 
    {
        $$ = new expression_t(TYPE_ENUM_INT);
						
        /* hw5 */
		string allocated_reg = regsPool->allocate_reg();
        // <Ramy>: after I changed the struct to union I had to change "$$.belongs_reg" to "$$->belongs_reg".
        // Note that "$$" now is of type "expression_t".
		$$->belongs_reg = allocated_reg;
		CodeBuffer::instance().emit("li $" + allocated_reg + ", " + *($1));
		
    }
| NUM StoreLineNum B 
    {
        
        int val = string_to_int(*($1));
        if (val > 255)
        {
            errorByteTooLarge(err_line, *($1));
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BYTE);
		
        /* hw5 */
		string allocated_reg = regsPool->allocate_reg();
        // <Ramy>: after I changed the struct to union I had to change "$$.belongs_reg" to "$$->belongs_reg".
        // Note that "$$" now is of type "expression_t".
		$$->belongs_reg = allocated_reg;
		CodeBuffer::instance().emit("li $" + allocated_reg + ", " + *($1));
    }
| STRING 
    {
        $$ = new expression_t(TYPE_ENUM_STRING);
		
        /* hw5 */
		string allocated_reg = regsPool->allocate_reg();
		$$->belongs_reg = allocated_reg;
        // <Ramy>: I changed this from $1.string_val to *($1) because it didn't compile after I
        // changed the struct to union
		CodeBuffer::instance().emit("la $" + allocated_reg + ", " + "var" + *($1));
		
    }
| TRUE 
    {
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Set a jump destination to be backpatched for the current epxression.
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> true".
        int emitted_offset = CodeBuffer::instance().emit("j ");
        $$->true_list = CodeBuffer::instance().makelist(emitted_offset);
    }
| FALSE 
    {
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Set a jump destination to be backpatched for the current epxression.
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> false".
        int emitted_offset = CodeBuffer::instance().emit("j ");
        $$->false_list = CodeBuffer::instance().makelist(emitted_offset);
    }
| NOT Exp %prec NOT
    {
        if($2->type != TYPE_ENUM_BOOL)
        {
            errorMismatch(yylineno);
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> not B1"
        $$->true_list = $2->false_list;
        $$->false_list = $$->true_list;
    }
| Exp AND GENERATE_AND_EMIT_LABEL Exp %prec AND
    {
        //hw5: I added a marker "GENERATE_AND_EMIT_LABEL", therefore I changed "$3->type" to "$4->type"
        if($1->type != TYPE_ENUM_BOOL || $4->type != TYPE_ENUM_BOOL)
        {
            errorMismatch(yylineno);
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> B1 and B2"

        // set "label_to_jump" as the jump destination of all branches in the true list
        // of the first expression.
        // Note that "label_to_jump" is a label that was generated and emitted by
        // "GENERATE_AND_EMIT_LABEL" marker.
        CodeBuffer::instance().bpatch($1->true_list, label_to_jump);

        // Set the true list of the result expression to be the true list of the second expression
        $$->true_list = $4->true_list;

        // Set the false list of the result expression to contain all of the offsets in the false
        // list of the first expression and the false list of the second expression
        $$->false_list = CodeBuffer::instance().merge($1->false_list, $4->false_list);
    }
| Exp OR GENERATE_AND_EMIT_LABEL Exp %prec OR
    {
        //hw5: I added a marker "GENERATE_AND_EMIT_LABEL", therefore I changed "$3->type" to "$4->type"
        if($1->type != TYPE_ENUM_BOOL || $4->type != TYPE_ENUM_BOOL)
        {
            errorMismatch(yylineno);
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> B1 or B2"

        // set "label_to_jump" as the jump destination of all branches in the false list
        // of the first expression.
        // Note that "label_to_jump" is a label that was generated and emitted by
        // "GENERATE_AND_EMIT_LABEL" marker.
        CodeBuffer::instance().bpatch($1->false_list, label_to_jump);

        // Set the false list of the result expression to be the false list of the second expression
        $$->false_list = $4->false_list;

        // Set the true list of the result expression to contain all of the offsets in the true
        // list of the first expression and the true list of the second expression
        $$->true_list = CodeBuffer::instance().merge($1->true_list, $4->true_list);
    }
| Exp RELATIONAL Exp %prec RELATIONAL
    {
        if(!type_is_numeric($1->type) || !type_is_numeric($3->type))
        {
            errorMismatch(yylineno);
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> id1 relop id2"

        // Emit conditional branch instruction corresponding to the received RELATIONAL, and store
        // the emitted offset into "emitted_offset_for_true_list"
        // "emit('if' id1.var relop id2.var 'goto _');"
        int emitted_offset_for_true_list = emit_conditional_branch_for_relational_operation(
            *($1) /* left_expression */,
            *($2) /* relational_operation */,
            *($3) /* right_expression */);

        // "emit('goto _');"
        int emitted_offset_for_false_list = CodeBuffer::instance().emit("j ");
        
        // "B.trueList = [nextInstr];
        // B.falseList = [nextInstr+1];"
        $$->true_list = CodeBuffer::instance().makelist(emitted_offset_for_true_list);
        $$->false_list = CodeBuffer::instance().makelist(emitted_offset_for_false_list);
    }
| Exp EQ Exp %prec EQ
    {
        if(!type_is_numeric($1->type) || !type_is_numeric($3->type))
        {
            errorMismatch(yylineno);
            exit(0);
        }
        $$ = new expression_t(TYPE_ENUM_BOOL);

        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "B -> id1 relop id2"

        // Emit conditional branch instruction corresponding to the received RELATIONAL, and store
        // the emitted offset into "emitted_offset_for_true_list"
        // "emit('if' id1.var relop id2.var 'goto _');"
        int emitted_offset_for_true_list = emit_conditional_branch_for_relational_operation(
            *($1) /* left_expression */,
            *($2) /* relational_operation */,
            *($3) /* right_expression */);

        // "emit('goto _');"
        int emitted_offset_for_false_list = CodeBuffer::instance().emit("j ");
        
        // "B.trueList = [nextInstr];
        // B.falseList = [nextInstr+1];"
        $$->true_list = CodeBuffer::instance().makelist(emitted_offset_for_true_list);
        $$->false_list = CodeBuffer::instance().makelist(emitted_offset_for_false_list);

    }

GENERATE_AND_EMIT_LABEL : 
    {
        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "M -> epsilon"

        // Generate and emit a label and store it into "label_to_jump" global variable.
        // This label will be later sent to CodeBuffer:bpatch() to be used as a jump destination.
        label_to_jump = CodeBuffer::instance().genLabel();
    }
GENERATE_AND_EMIT_LABEL2 :
    {
        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching Boolean expressions",
        // "M -> epsilon"

        // Generate and emit a label and store it into "label_to_jump" global variable.
        // This label will be later sent to CodeBuffer:bpatch() to be used as a jump destination.
        label_to_second_jump = CodeBuffer::instance().genLabel();
    }

EMIT_JUMP_BEFORE_ELSE :
    {
        /* hw5 */
        // Lectures slides, lecture 6 "Intermediate Representation", "Backpatching for Statements",
        // "N -> epsilon"

        CodeBuffer::instance().emit("j ");
    }

%%

int main()
{
    yydebug = 0;
	tables = vector<vector<attribute_t*> >(0);
    offsets = vector<int>(0);
    yyparse();
    return 0;
}

int yyerror(char* s)
{
    errorSyn(yylineno);
    exit(0);
    return 0;
}