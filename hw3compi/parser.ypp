%{
	#include "attributes.h"
    #include<stdio.h>
    using namespace std;
    extern int yylex();
	int yyerror(char * message);
%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token STRUCT
%token AND
%token OR
%token NOT
%token TRUE
%token FALSE
%token RETURN
%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token PERIOD
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token ASSIGN
%token RELOP
%token BINOP
%token ID
%token NUM
%token STRING

%%

Program : Structs Funcs
Funcs : 
 | FuncDecl Funcs
FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE AtLeastOneOpenStatement RBRACE
| RetType ID LPAREN Formals RPAREN LBRACE ClosedStatements RBRACE
Structs : 
| StructsDecl Structs
StructsDecl : STRUCT ID LBRACE StructMemList RBRACE SC
RetType : Type 
| VOID
Formals :  
| FormalsList
FormalsList : FormalDecl 
| FormalDecl COMMA FormalsList
FormalDecl : Type ID 
| StructType ID
StructMemList : StructMem 
| StructMem StructMemList
StructMem : Type ID SC

// Define rules for parsing statements in such a way the "dangling else" conflict will be solved.
// In order to solve the "danlging else" conflict, we define the grammar rules in such a way that
// when we get a list of "if"s and "else"s we do the following parsing:
// Starting from the leftmost "else", match every "else" to the rightest free "if" on its left
// (a "free if" is an if which we didn't match it an "else" yet).
// For supporting the above behavior, We divivde statements to "open statements" and "closed 
// statements".
// an "open statement" is defined to be a statement that includes at least one "if" without matching 
// else.
// and a "closed statement" is defined to be a statements in which every "if" has matching "else".
// The following rules support parsing "Statements" while keeping the behaviour explained above. 


// We define "AtLeastOneOpenStatement" to be a list of statements which contain some number of statements,
// but one of these statements have to be open statement
/* Option 1: this list contains mere one open statement */
AtLeastOneOpenStatement: OpenStatement
/* Option2: this list ends with an open statement, and the rest of the list can contain any
   kind of statements */
| AtLeastOneOpenStatement OpenStatement
| ClosedStatements OpenStatement
/* Option3: this list can ends with a closed statement, and the rest of the list must contain at
   least one open statement, which means the rest of the list is of the kind "AtLeastOneOpenStatement" */ 
| AtLeastOneOpenStatement ClosedStatement

// We define "ClosedStatements" to be a list of closed statements
ClosedStatements: ClosedStatement
| ClosedStatements ClosedStatement

// Rules for an open statement.
// Note that a statement is only considered open if it contains at least one "if" which doesn't
// have a matching "else".
// Therefore, an open statement must either start with "if" or "while", or to consist of "LBRACE
// AtLeastOneOpenStatement RBRACE", because according to the grammar rules, these are the only ways
// for a statement to contain an "if".
/* Option1: the statement starts with "if" which doesn't have its matching else.
   Note that in this case the "if" block can contain any kind of statement (open or closed) */
OpenStatement: IF LPAREN Exp RPAREN OpenStatement
| IF LPAREN Exp RPAREN ClosedStatement
/* Option2: the statement starts with "if" which have its matching else.
   Note that in this case the "if" block can only contain closed statement, because otherwise, it
   would contain at least one "if" without a matching else, but according to our behaviour for
   dealing with multiple "if"s and "else"s list (see explanation above),  this "if" must be matched
   to the "ELSE" in the current rule */
| IF LPAREN Exp RPAREN ClosedStatement ELSE OpenStatement
/* Option3: the statement starts with "while".
   Note In this case, the "while" block must contain at least one "if" without its matching "else",
   which means it must contain "OpenStatement"
| WHILE LPAREN Exp RPAREN OpenStatement */
/* Option4: the statement consist of LBRACE AtLeastOneOpenStatement RBRACE */
| LBRACE AtLeastOneOpenStatement RBRACE

// Rules for a closed statement.
// Note that in a closed statement, every if must have its matching else.
ClosedStatement: SimpleStatement
| IF LPAREN Exp RPAREN ClosedStatement ELSE ClosedStatement
| WHILE LPAREN Exp RPAREN ClosedStatement 
| LBRACE ClosedStatements RBRACE

SimpleStatement: Type ID SC 
| StructType ID SC 
| STRUCT ID LBRACE StructMemList RBRACE SC 
| Type ID ASSIGN Exp SC 
| StructType ID ASSIGN Exp SC 
| ID ASSIGN Exp SC 
| ID PERIOD ID ASSIGN Exp SC 
| Call SC 
| RETURN SC 
| RETURN Exp SC 
| BREAK SC 
| CONTINUE SC
Call : ID LPAREN ExpList RPAREN 
| ID LPAREN RPAREN
ExpList : Exp 
| Exp COMMA ExpList
Type : INT 
| BYTE 
| BOOL
StructType : STRUCT ID
Exp :LPAREN Exp RPAREN 
| Exp BINOP Exp 
| ID 
| ID PERIOD ID 
| Call 
| NUM 
| NUM B 
| STRING 
| TRUE 
| FALSE 
| NOT Exp 
| Exp AND Exp 
| Exp OR Exp 
| Exp RELOP Exp

%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
}